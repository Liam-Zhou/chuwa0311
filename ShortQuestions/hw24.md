2.
The volatile keyword is used to indicate that a variable's value may be changed unexpectedly by multiple threads. It provides atomic access to the variable.

3.
a) Extends "thread" class;
b) Implements "Runnable" interface;
c) Lambda expression;
d) ExecutorService.

4.
Runnable does not return a value directly and the run() method throws a checked exception, it must be caught and handled within the run() method itself;
Callable  returns a result of type V (generic type) when its call() method is invoked and Exception handling involves declaring or catching checked exceptions that can be thrown by the call() method.

5.
t.start() : creates a new thread of execution and starts that thread, the new thread runs concurrently with the main thread or other threads, depending on the system's scheduling;
t.run() : simply executes the run() method on the current thread, without creating a new thread.

6.
They have their advantages and disadvantages. Generally Runnable interface promotes better separation of concerns, code reuse, and flexibility in threading mechanisms.
For Thread class:
pros: simplicity, direct control and easier for small, simple tasks;
cons: limited inheritance, less flexibility.

For Runnable interface:
pros: better separation of concerns, flexibilty and supports multiple inheritance;
cons: requires additional boilerplate code, Indirect control over thread lifecycle.

7.
Represent the possible states of a Java thread. There are "NEW", "RUNNABLE","BLOCKED", "WAITING", TIMED_WAITING", "TERMINATED", they represent the progression of a thread's lifecycle, from creation to termination. 

8.
A situation in concurrent programming where two or more threads or processes are unable to proceed with their execution because each of them is waiting for a resource that is held by another thread or process in the same group.

9.
synchronized blocks and methods; communicate directly with each other using methods like wait(), notify(), and notifyAll() provided by the Object class; Thread Pools.

10.
Class Lock (Static Synchronization): It is associated with a class and is used to synchronize access to static methods or static synchronized blocks within that class;
Object Lock (Instance Synchronization): It is associated with an instance (object) of a class and is used to synchronize access to instance methods or synchronized blocks within that instance.

11.
join() allows one thread to wait for the completion of another thread before continuing its own execution.

12.
yield() suggests to the scheduler that the current thread is willing to yield its current execution and allow other threads to run.

13.
ThreadPool is a managed collection of threads that are available for executing tasks.
Types: FixedThreadPool, CachedThreadPoolï¼ŒScheduledThreadPool and SingleThreadExecutor
TaskQueue in a ThreadPool is a data structure used to hold pending tasks that are waiting to be executed by the available threads. 

14.
java.util.concurrent. ExecutorService interface.

15.
Use use one of the factory methods provided by the Executors class to create different types of ThreadPool implementations;
Define the task you want to submit to the ThreadPool as a Runnable or Callable object;
Use the submit() method of the ExecutorService interface to submit the task to the ThreadPool for execution.

16.
Resource Management, Improved Performance, Concurrency Control, Scalability, Centralized Configuration and Fault Tolerance.

17.
shutdown() method initiates an orderly shutdown of the ExecutorService, allowing tasks to complete execution before shutting down, while shutdownNow() attempts to stop the ExecutorService immediately, interrupting tasks.

18.
Atomic classes provide atomic operations on single variables without the need for explicit synchronization, making them suitable for concurrent programming scenarios where thread safety is essential.
AtomicInteger, AtomicLong, AtomicBoolean, and AtomicReference.
code:

public class AtomicExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);
        System.out.println("Initial value: " + counter.get());
        counter.incrementAndGet();
	System.out.println("After increment: " + counter.get());

	counter.addAndGet(5); // Add 5
        System.out.println("After add: " + counter.get());
        counter.addAndGet(-3); // Subtract 3
        System.out.println("After subtract: " + counter.get());
    }
}

19.
Data structures that are designed to be thread-safe and support concurrent access by multiple threads without the need for external synchronization.
ConcurrentHashMap, ConcurrentLinkedQueue, ConcurrentSkipListMap, ConcurrentSkipListSet and etc.

20.
Synchronized Lock: Simple to use and understand; Supports reentrant locking; Provides intrinsic locking and mutual exclusion.
ReentrantLock: Provides explicit locking and unlocking mechanisms using the lock() and unlock() methods, offering more flexibility and control than synchronized blocks.
ReadWriteLock: Provides separate locks for reading (readLock()) and writing (writeLock()), allowing multiple threads to read concurrently but ensuring exclusive access for writing; Supports upgrading and downgrading locks.

21.
classes that represent asynchronous computations and provide a way to obtain results or handle exceptions from asynchronous tasks.
thenApply, thenAccept, thenRun, thenCombine, exceptionally, anyOf and allOf.

22.
see Coding/coding_hw24

23,24,25 same
