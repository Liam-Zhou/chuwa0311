# Zeyu Cui Homework 2
## 1. Write up Example code to demonstrate the three foundmental concepts of OOP. (reference Code Demo
repo as example)
```
1. Encapsulation;
2. Polymorphism;
3. Inheritance;
```
https://github.com/ZeyuCui/bird

## 2. What is wrapper class in Java and Why we need wrapper class?
In Java, a wrapper class is a class that encapsulates, or "wraps," a primitive data type within an object. 
Each primitive data type in Java has a corresponding wrapper class. 
The wrapper classes provide a way to treat primitive data types as objects, allowing them to be used in contexts that require objects, such as collections
```
byte : Byte
short : Short
int : Integer
long : Long
float : Float
double : Double
char : Character
boolean : Boolean

```

## 3. What is the difference between HashMap and HashTable?
### 1. Synchronization
Firstly, Hashtable is thread-safe and can be shared between multiple threads in the application.

On the other hand, HashMap is not synchronized and can’t be accessed by multiple threads without additional synchronization code. We can use Collections.synchronizedMap() to make a thread-safe version of a HashMap. We can also just create custom lock code or make the code thread-safe by using the synchronized keyword.

HashMap is not synchronized, therefore it’s faster and uses less memory than Hashtable. Generally, unsynchronized objects are faster than synchronized ones in a single threaded application.

### 2. Null Values
Another difference is null handling. HashMap allows adding one Entry with null as key as well as many entries with null as value. 
In contrast, Hashtable doesn’t allow null at all. Let’s see an example of null and HashMap:

### 3. Iteration Over Elements
HashMap uses Iterator to iterate over values, whereas Hashtable has Enumerator for the same. 
The Iterator is a successor of Enumerator that eliminates its few drawbacks. For example, Iterator has a remove() method to remove elements from underlying collections.

The Iterator is a fail-fast iterator. In other words, it throws a ConcurrentModificationException when the underlying collection is modified while iterating. Let’s see the example of fail-fast:

### 4. When to Choose HashMap Over Hashtable
We should use HashMap for an unsynchronized or single threaded application. It is worth mentioning that since JDK 1.8, Hashtable has been deprecated. However, ConcurrentHashMap is a great Hashtable replacement. We should consider ConcurrentHashMap to use in applications with multiple threads.

## 4. What is String pool in Java and why we need String pool?

In Java, the "String pool" is a special area in the JVM (Java Virtual Machine) **heap memory** where Java maintains a pool of string literals. 
When you create a string literal in Java using double quotes (e.g., "hello"), the JVM checks if an identical string already exists in the string pool. 
If it does, the new string literal references the existing string object in the pool. If not, a new string object is created in the pool.

String pool in Java provides **memory efficiency, performance optimization, and ensures the immutability and consistency of string objects** throughout the execution of Java programs.

## 5. What is Java garbage collection?

Java garbage collection is the automatic process of reclaiming memory occupied by objects that are no longer in use by the Java application. 
In Java, memory management is handled automatically by the JVM (Java Virtual Machine), which includes a garbage collector responsible for identifying and reclaiming memory allocated to objects that are no longer referenced by the application.

## 6. What are access modifiers and their scopes in Java?
In Java, access modifiers are keywords used to control the **visibility or accessibility** of classes, fields, methods, and constructors. 
Access modifiers help enforce encapsulation and maintain the integrity of the code by restricting access to certain parts of a program.

Public: anywhere
Protected: within the same package and subclasses (even if they are in different packages).
Default (package-private): If no access modifier is specified, the default access modifier is applied.
Default members are accessible only within the same package.
Private: only within the same class.


## 7. What is final key word? (Filed, Method, Class)

### Final Field:
Primitive type : Once you set its value, you can't change it.
Reference type: In Java, a final field with a reference type means that once the field is initialized, its reference cannot be changed to point to another object. However, the state of the object itself (i.e., its fields) can still be modified if the object is mutable.
### Final Method: a method that can't be changed by subclasses. It keeps its behavior fixed.
### Final Class: It's a class that can't be extended. No other class can inherit from it.

## 8. What is static keyword? (Filed, Method, Class). When do we usually use it?
### Static Field:
It's like a shared variable for all objects of a class.
You use the class name to access it, not an instance of the class.
 
### Static Method:
It's a method that belongs to the class, not an instance.
You call it using the class name.
 
### Static Class (Nested Class):
It's a class inside another class, but it can be used without creating an instance of the outer class. It can't directly access non-static stuff in the outer class.

 the static keyword is used to declare members of a class that belong to the class itself, rather than to individual instances. 
It is commonly used for **utility methods, constants, factory methods, implementing design patterns, and defining nested classes**.

## 9. What is the differences between overriding and overloading?

Overriding involves a subclass providing a specific implementation for a method inherited from its superclass, with the same method signature. It's used for runtime polymorphism and is related to inheritance.

Overloading occurs when a class has multiple methods with the same name but different parameter lists. It's used for compile-time polymorphism and doesn't require inheritance.

## 10. What is the differences between super and this?

super is used to access superclass members and to call superclass constructors, while this is used to refer to the current instance of the class and to access its members.
super: Accesses superclass members, calls superclass constructors.
this: Refers to the current instance, accesses current object's members.
super is commonly used in subclass constructors to call superclass constructors, while this is often used to differentiate between instance variables and parameters with the same name.

## 11. What is the Java load sequence?

The Java class loading sequence involves three main steps:

Loading: The class file is located and read, then stored in memory.

Linking: Verification, preparation (allocation of memory for static fields), and resolution (replacing symbolic references with direct ones) are performed.

Initialization: Static variables are initialized with explicit values, and static initialization blocks are executed.

After initialization, the class is ready for execution.

## 12. What is Polymorphism ? And how Java implements it ?

Polymorphism in java is a concept by which we can perform a single action by different ways.
Compile time Polymorphism
-  The form is determined at compile time
-  Method overloading
-  a class has multiple methods having same name but different in
parameters
- Different number of parameters
-  Different data type of parameters
-  Method overloading increases the readability of the program
Runtime Polymorphism
- The form is determined at runtime
- Method overriding
- a method in a subclass has the same name and return type as a
method in its superclass, then the method in the subclass is said to
override the method in the superclass
- When an overridden method is called through the subclass object, it
will always refer to the version of the method defined by the
subclass. The superclass version of the method is hidden

## 13. What is Encapsulation ? How Java implements it? And why we need encapsulation?

Encapsulation
- Encapsulation is hiding information.
- An Wrapper class (Integer) is an example of Encapsulation
- How
- Making the fields in a class private and providing access to the fields via
public methods
- Why
- Flexibility — Internal logic changes won’t affect the caller of the method
- Reusability — Encapsulated code can be used by different callers
- Maintainability — Operations on encapsulated unit won’t affect others
parts

## 14. What is Interface and what is abstract class? What are the differences between them?

Interface is a group of related methods with empty bodies.
Abstract class is a class that can not be initiated by itself, it needs to be subclassed by another class to use its properties. An abstract class is declared using the “abstract” keyword in its class definition.

## 15. design a parking lot 
(put the code to codingQuestions/coding1 folder, )

## 16. What are Queue interface implementations and what are the differences and when to use what?
**LinkedList**: General-purpose, flexible, suitable when flexibility in adding/removing elements from both ends is needed.
**ArrayDeque**: High-performance, resizable, suitable for performance-critical applications requiring fast insertion/removal from both ends.
**PriorityQueue**: Orders elements based on priority, suitable when elements need to be processed based on their priority.
**BlockingQueue** Implementations: Provide blocking operations for concurrent programming, suitable for producer-consumer scenarios requiring synchronization. Choose based on specific requirements like bounded vs. unbounded capacity, fairness, and ordering needs.
